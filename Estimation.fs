namespace FsAdvent2022

module Estimation =

    open DiffSharp
    open DiffSharp.Model
    open Weibull
    open FsAdvent2022.Simulation

    let diffprog parameters (f: 'In -> 'Out) : Model<'In, 'Out> =
        Model<'In, 'Out>.create [] parameters [] f

    let prepare (index: int) (tape: Incident []) =
        tape
        |> Array.pairwise
        |> Array.map (fun (previousIncident, incident) ->
            incident.Cause = index,
            (incident.FailureTime - previousIncident.RestartTime).TotalHours
            )

    let pdf (lambda: Parameter, k: Parameter) =
        (fun (time: float) ->
            (k.value / lambda.value)
            *
            ((time / lambda.value) ** (k.value - 1.0))
            *
            exp (- ((time / lambda.value) ** k.value))
        )

    let cdf (lambda: Parameter, k: Parameter) =
        (fun (time: float) ->
            dsharp.scalar 1.0
            - exp (- ((time / lambda.value) ** k.value))
        )

    // given a competing Weibull, with its observation index,
    // what is the likelihood of observing index i, time t?
    let likelihood (weibull: Weibull) =

        let lambda = weibull.Lambda |> dsharp.scalar |> Parameter
        let k = weibull.K |> dsharp.scalar |> Parameter

        diffprog [| lambda; k |]
            (fun (observed: bool, time: float) ->
                if observed
                then pdf (lambda, k) time
                else dsharp.scalar 1.0 - cdf (lambda, k) time
            )

    // Likelihood that a sample was generated by a Weibull
    let sampleLikelihood
        (sample: (bool * float) [])
        (likelihood: Model<(bool * float), Tensor>) =
            sample
            |> Array.sumBy (fun (observed, time) ->
                likelihood.forward (observed, time)
                |> dsharp.log
                )

    let estimate (sample: (bool * float) []) =

        let maxIterations = 100

        dsharp.config (backend = Backend.Torch, device = Device.CPU)
        dsharp.seed(1) |> ignore

        let maximizeLikelihood
            (likelihood: Model<bool * float, Tensor>)
            (sample: (bool * float)[]) =

            let lr = 0.001 |> dsharp.scalar
            let tolerance = 0.001 |> dsharp.scalar

            let rec search iter =

                likelihood.reverseDiff()
                let l: Tensor = sampleLikelihood sample likelihood
                l.reverse()

                // clip lambda, k values so they remain >= 0.01
                let p = likelihood.parametersVector
                let change =
                    p.primal + lr * p.derivative
                likelihood.parametersVector <- change

                // progress indication
                let lambda = likelihood.parametersVector.[0] |> float
                let k = likelihood.parametersVector.[1] |> float
                printfn $"Iter {iter}: k = {k}, lambda = {lambda}"

                // termination: changes close to 0
                if (dsharp.norm (lr * p.derivative) <= tolerance)
                then likelihood
                // termination: max iterations reached
                elif iter >= maxIterations
                then likelihood
                else search (iter + 1)

            search 1

        let initialGuess = { K = 1.0; Lambda = 1.0 }
        let likelihoodFunction = likelihood initialGuess
        let maximized = maximizeLikelihood likelihoodFunction sample

        let estimated =
            {
                Lambda = maximized.parametersVector.[0] |> float
                K = maximized.parametersVector.[1] |> float
            }

        estimated